# -*- coding: utf-8 -*-
"""K means Clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EZkoqtTfIZ92nlhCm_JxZCwBi6fjNRLP
"""

import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import seaborn as sns

# Load the data (assuming 'realtor.csv' is in the same directory)
df = pd.read_csv("realtor.csv")

# Handle missing values (example: fill missing zip codes with 'Unknown')
df['zip_code'].fillna('Unknown', inplace=True)

# Select features for clustering
features = ['bed', 'bath', 'acre_lot', 'house_size']
X = df[features]

# Standardize the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Determine the optimal number of clusters (e.g., using the Elbow Method - implementation not shown here)
n_clusters = 3  # Assuming 3 clusters for this example

# Create and fit the K-Means model
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
kmeans.fit(X_scaled)

# Add cluster labels to the DataFrame
df['cluster'] = kmeans.labels_

# Calculate cluster centers (in original feature space)
cluster_centers_scaled = kmeans.cluster_centers_
cluster_centers = scaler.inverse_transform(cluster_centers_scaled)

# Create a box plot of price by cluster and city
plt.figure(figsize=(12, 6))
sns.boxplot(x='city', y='price', hue='cluster', data=df)
plt.title('House Prices by City and Cluster')
plt.xlabel('City')
plt.ylabel('Price')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Cluster')
plt.show()

# Create a bar plot of average price per cluster for each city
city_cluster_means = df.groupby(['city', 'cluster'])['price'].mean().reset_index()
plt.figure(figsize=(12, 6))
sns.barplot(x='city', y='price', hue='cluster', data=city_cluster_means)
plt.title('Average House Price by City and Cluster')
plt.xlabel('City')
plt.ylabel('Average Price')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Cluster')
plt.show()

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import seaborn as sns
from geopy.geocoders import Nominatim
import geopandas as gpd
from shapely.geometry import Point
from tensorflow.keras.layers import Embedding, Input, Flatten, Concatenate, Dense
from tensorflow.keras.models import Model

class DataPreprocessor:
    """
    Preprocesses the real estate data.
    """

    def __init__(self):
        self.scaler = StandardScaler()

    def preprocess(self, df):
        """
        Preprocesses the DataFrame.

        Args:
            df: DataFrame containing the real estate data.

        Returns:
            Preprocessed DataFrame.
        """
        # Handle missing values (example: fill missing zip codes with 'Unknown')
        df['zip_code'].fillna('Unknown', inplace=True)

        # Select features for clustering
        features = ['bed', 'bath', 'acre_lot', 'house_size']
        X = df[features]

        # Standardize the features
        X_scaled = self.scaler.fit_transform(X)

        # Add standardized features to the DataFrame
        df[f'{feature}_scaled' for feature in features] = X_scaled

        return df

class KMeansClusterer:
    """
    Performs K-Means clustering on the data.
    """

    def __init__(self, n_clusters=3, random_state=42):
        self.n_clusters = n_clusters
        self.random_state = random_state
        self.kmeans = KMeans(n_clusters=n_clusters, random_state=random_state)

    def fit(self, X):
        """
        Fits the K-Means model to the data.

        Args:
            X: Standardized features for clustering.
        """
        self.kmeans.fit(X)

    def predict(self, X):
        """
        Predicts cluster labels for new data.

        Args:
            X: Standardized features to predict cluster labels for.

        Returns:
            Predicted cluster labels.
        """
        return self.kmeans.predict(X)

    def get_cluster_centers(self):
        """
        Returns the cluster centers.

        Returns:
            Cluster centers.
        """
        return self.kmeans.cluster_centers_

class Geocoder:
    """
    Geocodes addresses to obtain latitude and longitude.
    """

    def __init__(self):
        self.geolocator = Nominatim(user_agent="my_geocoder")

    def geocode_address(self, row):
        try:
            location = self.geolocator.geocode(f"{row['street']} {row['city']}, {row['state']} {row['zip_code']}")
            if location:
                return location.latitude, location.longitude
            else:
                return None, None
        except Exception as e:
            print(f"Error geocoding address: {e}")
            return None, None

class RecommendationSystem:
    """
    Builds and trains a recommendation system using a neural network.
    """

    def __init__(self, num_users, num_properties, embedding_dim=64):
        self.num_users = num_users
        self.num_properties = num_properties
        self.embedding_dim = embedding_dim

        # Define input layers
        user_input = Input(shape=(1,), dtype='int32', name='user_input')
        property_input = Input(shape=(1,), dtype='int32', name='property_input')

        # Embedding layers
        user_embedding = Embedding(num_users, embedding_dim)(user_input)
        property_embedding = Embedding(num_properties, embedding_dim)(property_input)

        # Flatten embeddings
        user_embedding = Flatten()(user_embedding)
        property_embedding = Flatten()(property_embedding)

        # Concatenate embeddings
        concatenated = Concatenate()([user_embedding, property_embedding])

        # Hidden layers (you can adjust the architecture)
        hidden1 = Dense(128, activation='relu')(concatenated)
        hidden2 = Dense(64, activation='relu')(hidden1)

        # Output layer
        output = Dense(1, activation='sigmoid')(hidden2)

        # Create the model
        self.model = Model(inputs=[user_input, property_input], outputs=output)

        # Compile the model
        self.model.compile(optimizer='adam', loss='binary_crossentropy')

    def train(self, user_input_train, property_input_train, ratings_train, epochs=10, batch_size=32):
        """
        Trains the recommendation model.

        Args:
            user_input_train: Training data for user IDs.
            property_input_train: Training data for property IDs.
            ratings_train: Training data for user-property ratings.
            epochs: Number of epochs to train the model.
            batch_size: Batch size for training.
        """
        self.model.fit([user_input_train, property_input_train], ratings_train, epochs=epochs, batch_size=batch_size)

    def predict(self, user_input, property_input):
        """
        Predicts interaction scores for new user-property pairs.

        Args:
            user_input: User IDs for prediction.
            property_input: Property IDs for prediction.

        Returns:
            Predicted interaction scores.
        """
        return self.model.predict([user_input, property_input])

# Example usage
# (Assumes you have the necessary data preprocessing and model training steps)
# ...

# Use the trained model to make recommendations for a new user
# (Assuming the new user ID is 4)
new_user_id = 4
predicted_ratings = model.predict(